<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BuyiXiao&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/d8d183d1caef8e675edc72dbd213a438</icon>
  
  <link href="https://buyixiao.github.io/atom.xml" rel="self"/>
  
  <link href="https://buyixiao.github.io/"/>
  <updated>2023-05-22T08:05:01.441Z</updated>
  <id>https://buyixiao.github.io/</id>
  
  <author>
    <name>BuyiXiao</name>
    <email>2391527690@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>matplotlib 折线图颜色分段显示</title>
    <link href="https://buyixiao.github.io/blog/matplotlib-segmented-color-graph.html"/>
    <id>https://buyixiao.github.io/blog/matplotlib-segmented-color-graph.html</id>
    <published>2023-05-13T08:40:58.000Z</published>
    <updated>2023-05-22T08:05:01.441Z</updated>
    
    <content type="html"><![CDATA[<p>近来需要画一个多段折线图，并且每段颜色都不一样，搜索得知，大部分已有的实现都是基于 <code>matplotlib</code> 的<code>LineCollection</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.collections <span class="keyword">import</span> LineCollection</span><br></pre></td></tr></table></figure><p>这种方式还要自己组装 segments ，略显晦涩，索性自己实现了。效果如下：</p><p><img src="https://s2.loli.net/2023/05/13/7LDzWrkYbZjK4Gx.png" alt="segmented-color buyixiao blog"></p><p>其中 x，y 序列大致如下，没什么特殊的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x</span><br><span class="line"> [<span class="string">&#x27;2023-02-06 12&#x27;</span>, <span class="string">&#x27;2023-02-06 18&#x27;</span>, <span class="string">&#x27;2023-02-07 00&#x27;</span>, <span class="string">&#x27;2023-02-07 06&#x27;</span>, <span class="string">&#x27;2023-02-07 12&#x27;</span>, <span class="string">&#x27;2023-02-07 18&#x27;</span>, <span class="string">&#x27;2023-02-08 00&#x27;</span>, <span class="string">&#x27;2023-02-08 06&#x27;</span>, <span class="string">&#x27;2023-02-08 12&#x27;</span>, <span class="string">&#x27;2023-02-08 18&#x27;</span>, <span class="string">&#x27;2023-02-09 00&#x27;</span>, <span class="string">&#x27;2023-02-09 06&#x27;</span>, <span class="string">&#x27;2023-02-09 12&#x27;</span>, <span class="string">&#x27;2023-02-09 18&#x27;</span>, <span class="string">&#x27;2023-02-10 00&#x27;</span>, <span class="string">&#x27;2023-02-10 06&#x27;</span>, <span class="string">&#x27;2023-02-10 12&#x27;</span>, <span class="string">&#x27;2023-02-10 18&#x27;</span>, <span class="string">&#x27;2023-02-11 00&#x27;</span>, <span class="string">&#x27;2023-02-11 06&#x27;</span>, <span class="string">&#x27;2023-02-11 12&#x27;</span>, <span class="string">&#x27;2023-02-11 18&#x27;</span>, <span class="string">&#x27;2023-02-12 00&#x27;</span>, <span class="string">&#x27;2023-02-12 06&#x27;</span>, <span class="string">&#x27;2023-02-12 12&#x27;</span>, <span class="string">&#x27;2023-02-12 18&#x27;</span>, <span class="string">&#x27;2023-02-13 00&#x27;</span>, <span class="string">&#x27;2023-02-13 06&#x27;</span>, <span class="string">&#x27;2023-02-13 12&#x27;</span>, <span class="string">&#x27;2023-02-13 18&#x27;</span>, <span class="string">&#x27;2023-02-14 00&#x27;</span>, <span class="string">&#x27;2023-02-14 06&#x27;</span>, <span class="string">&#x27;2023-02-14 12&#x27;</span>, <span class="string">&#x27;2023-02-14 18&#x27;</span>, <span class="string">&#x27;2023-02-15 00&#x27;</span>, <span class="string">&#x27;2023-02-15 06&#x27;</span>, <span class="string">&#x27;2023-02-15 12&#x27;</span>, <span class="string">&#x27;2023-02-15 18&#x27;</span>, <span class="string">&#x27;2023-02-16 00&#x27;</span>, <span class="string">&#x27;2023-02-16 06&#x27;</span>, <span class="string">&#x27;2023-02-16 12&#x27;</span>, <span class="string">&#x27;2023-02-16 18&#x27;</span>, <span class="string">&#x27;2023-02-17 00&#x27;</span>, <span class="string">&#x27;2023-02-17 06&#x27;</span>, ...]</span><br><span class="line"> </span><br><span class="line"> y</span><br><span class="line">  [   <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span></span><br><span class="line">    <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">3</span>    <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span></span><br><span class="line">    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span></span><br><span class="line">    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">2</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>    <span class="number">4</span>  <span class="number">375</span>   <span class="number">83</span>  <span class="number">145</span>   <span class="number">15</span>  <span class="number">197</span>  <span class="number">264</span></span><br><span class="line">  <span class="number">135</span>   <span class="number">47</span>  <span class="number">164</span>   <span class="number">69</span>  <span class="number">116</span>   <span class="number">39</span>  <span class="number">109</span>   <span class="number">41</span>   <span class="number">54</span>   <span class="number">16</span>   <span class="number">20</span>   <span class="number">13</span>   <span class="number">27</span>   <span class="number">17.</span>..]</span><br></pre></td></tr></table></figure><h3 id="均分多段"><a href="#均分多段" class="headerlink" title="均分多段"></a>均分多段</h3><p>第一种需求是均分多段，即等分折现，其实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># author:           inspurer(月小水长)</span></span><br><span class="line"><span class="comment"># create_time:      2023/5/13 14:31</span></span><br><span class="line"><span class="comment"># 运行环境           Python3.6+</span></span><br><span class="line"><span class="comment"># github            https://github.com/inspurer</span></span><br><span class="line"><span class="comment"># website           https://buyixiao.github.io/</span></span><br><span class="line"><span class="comment"># 微信公众号         月小水长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> ticker</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 指定默认字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 解决保存图像是负号&#x27;-&#x27;显示为方块的问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unique_color</span>():</span></span><br><span class="line">    <span class="keyword">return</span> plt.cm.gist_ncar(np.random.random())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_colored_seg</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        均分多段</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x\n&#x27;</span>, x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;y\n&#x27;</span>, y)</span><br><span class="line"></span><br><span class="line">    seg_x_list = []</span><br><span class="line">    seg_y_list = []</span><br><span class="line"></span><br><span class="line">    max_x = <span class="built_in">max</span>(x)</span><br><span class="line">    max_y = <span class="built_in">max</span>(y)</span><br><span class="line"></span><br><span class="line">    seg_cnt = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    seg_label = [<span class="string">f&#x27;the label of <span class="subst">&#123;i&#125;</span>th turning point&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(seg_cnt)]</span><br><span class="line"></span><br><span class="line">    seg_point_cnt = <span class="built_in">len</span>(x) // seg_cnt</span><br><span class="line"></span><br><span class="line">    cur_seg_pointer = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, ele <span class="keyword">in</span> <span class="built_in">enumerate</span>(x):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(seg_x_list) &lt; seg_point_cnt <span class="keyword">and</span> index &lt; <span class="built_in">len</span>(x) - <span class="number">1</span>:</span><br><span class="line">            seg_x_list.append(ele)</span><br><span class="line">            seg_y_list.append(y[index])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur_color = unique_color()</span><br><span class="line">            plt.plot(seg_x_list, seg_y_list, color=cur_color)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur_seg_pointer &lt; seg_cnt:</span><br><span class="line">                plt.axvline(x[index - <span class="number">1</span>], color=cur_color, linestyle=<span class="string">&quot;dashed&quot;</span>)</span><br><span class="line">                plt.text(x[index - <span class="number">1</span>], max_y // <span class="number">1.5</span>, seg_label[cur_seg_pointer], fontsize=<span class="number">12</span>,</span><br><span class="line">                         ha=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">            seg_x_list = [x[index - <span class="number">1</span>]]</span><br><span class="line">            seg_y_list = [y[index - <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">            cur_seg_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    plt.gca().xaxis.set_major_locator(ticker.MultipleLocator(<span class="number">50</span>))</span><br><span class="line">    plt.ylim((<span class="number">0</span>, max_y))</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;per 6h&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;period weibo cnt&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># to prepare your own x,y list</span></span><br><span class="line">plot_colored_seg([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> ts_6h.index.strftime(<span class="string">&#x27;%Y-%m-%d %H&#x27;</span>)], ts_6h.values)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="值分多段"><a href="#值分多段" class="headerlink" title="值分多段"></a>值分多段</h3><p>第二种是值分多段，即按照 x 或者 y 的值划分多段，这种更灵活，可以说是均分多段的超集，其源代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># author:           inspurer(月小水长)</span></span><br><span class="line"><span class="comment"># create_time:      2023/5/13 14:31</span></span><br><span class="line"><span class="comment"># 运行环境           Python3.6+</span></span><br><span class="line"><span class="comment"># github            https://github.com/inspurer</span></span><br><span class="line"><span class="comment"># website           https://buyixiao.github.io/</span></span><br><span class="line"><span class="comment"># 微信公众号         月小水长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> ticker</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 指定默认字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 解决保存图像是负号&#x27;-&#x27;显示为方块的问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unique_color</span>():</span></span><br><span class="line">    <span class="keyword">return</span> plt.cm.gist_ncar(np.random.random())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_colored_seg_2</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        值分多段</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x\n&#x27;</span>, x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;y\n&#x27;</span>, y)</span><br><span class="line"></span><br><span class="line">    seg_x_list = []</span><br><span class="line">    seg_y_list = []</span><br><span class="line"></span><br><span class="line">    max_x = <span class="built_in">max</span>(x)</span><br><span class="line">    max_y = <span class="built_in">max</span>(y)</span><br><span class="line"></span><br><span class="line">    turn_points_x = [<span class="string">&#x27;2023-03-07 06&#x27;</span>, <span class="string">&#x27;2023-03-16 12&#x27;</span>, <span class="string">&#x27;2023-04-08 06&#x27;</span>]</span><br><span class="line">    seg_color_list = [unique_color() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(turn_points_x))]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, ele <span class="keyword">in</span> <span class="built_in">enumerate</span>(x):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ele <span class="keyword">in</span> turn_points_x:</span><br><span class="line">            turn_index = turn_points_x.index(ele)</span><br><span class="line">            cur_color = seg_color_list[turn_index]</span><br><span class="line">            plt.plot(seg_x_list, seg_y_list, color=cur_color)</span><br><span class="line">            plt.axvline(x[index - <span class="number">1</span>], color=cur_color, linestyle=<span class="string">&quot;dashed&quot;</span>)</span><br><span class="line">            plt.text(x[index - <span class="number">1</span>], max_y // <span class="number">1.5</span>, <span class="string">f&#x27;the label of <span class="subst">&#123;turn_index + <span class="number">1</span>&#125;</span>th turning point&#x27;</span>, fontsize=<span class="number">12</span>,</span><br><span class="line">                     ha=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            seg_x_list = [x[index - <span class="number">1</span>]]</span><br><span class="line">            seg_y_list = [y[index - <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            seg_x_list.append(ele)</span><br><span class="line">            seg_y_list.append(y[index])</span><br><span class="line"></span><br><span class="line">    plt.gca().xaxis.set_major_locator(ticker.MultipleLocator(<span class="number">50</span>))</span><br><span class="line">    plt.ylim((<span class="number">0</span>, max_y))</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;per 6h&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;period weibo cnt&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">   </span><br><span class="line"><span class="comment"># to prepare your own x,y list</span></span><br><span class="line">plot_colored_seg_2([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> ts_6h.index.strftime(<span class="string">&#x27;%Y-%m-%d %H&#x27;</span>)], ts_6h.values)</span><br></pre></td></tr></table></figure><p>转载请注明来源，如有更好的思路，欢迎留言~</p>]]></content>
    
    
    <summary type="html">一种通俗易懂的分段颜色折线图实现</summary>
    
    
    
    <category term="Python" scheme="https://buyixiao.github.io/categories/Python/"/>
    
    
    <category term="python" scheme="https://buyixiao.github.io/tags/python/"/>
    
    <category term="matplotlib" scheme="https://buyixiao.github.io/tags/matplotlib/"/>
    
    <category term="segmented-color" scheme="https://buyixiao.github.io/tags/segmented-color/"/>
    
    <category term="line-graph" scheme="https://buyixiao.github.io/tags/line-graph/"/>
    
  </entry>
  
  <entry>
    <title>pandas 将 json 转成 csv</title>
    <link href="https://buyixiao.github.io/blog/convert-json-to-csv.html"/>
    <id>https://buyixiao.github.io/blog/convert-json-to-csv.html</id>
    <published>2023-04-22T13:44:22.000Z</published>
    <updated>2023-04-22T14:19:48.702Z</updated>
    
    <content type="html"><![CDATA[<p>今天分享的是 <a href="https://buyixiao.github.io/tags/pandas/">【月小水长】pandas 三十六计系列</a> 的第八篇 ，一个小工具，将 json 文件转成 csv 文件。</p><p>文件格式是表，文件内容是里，只要里子一样，外表是可以像穿衣一样随便换的，就像在 MySQL 中，可以任意导入导出 SQL、csv、json 等文件一样。</p><p>假设我们有一个这样的 json 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;4893424946515214&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;mid&quot;</span>: <span class="string">&quot;4893424946515214&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;weibo_link&quot;</span>: <span class="string">&quot;https://weibo.com/2803301701/MDcporkU6&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;据悉，全城月季花已逐渐进入盛花期。&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;publish_time&quot;</span>: <span class="string">&quot;2023-04-22 20:34:45&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;user_link&quot;</span>: <span class="string">&quot;https://weibo.com/u/2803301701&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;user_name&quot;</span>: <span class="string">&quot;人民日报&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reposts_count&quot;</span>: <span class="number">55</span>,</span><br><span class="line">    <span class="attr">&quot;comments_count&quot;</span>: <span class="number">92</span>,</span><br><span class="line">    <span class="attr">&quot;attitudes_count&quot;</span>: <span class="number">298</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;4893416880346795&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;mid&quot;</span>: <span class="string">&quot;4893416880346795&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;weibo_link&quot;</span>: <span class="string">&quot;https://weibo.com/2803301701/MDcco1sdt&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;4月22日，陕西西安。游客发视频... &quot;</span>,</span><br><span class="line">    <span class="attr">&quot;publish_time&quot;</span>: <span class="string">&quot;2023-04-22 20:02:42&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;user_link&quot;</span>: <span class="string">&quot;https://weibo.com/u/2803301701&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;user_name&quot;</span>: <span class="string">&quot;人民日报&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reposts_count&quot;</span>: <span class="number">119</span>,</span><br><span class="line">    <span class="attr">&quot;comments_count&quot;</span>: <span class="number">249</span>,</span><br><span class="line">    <span class="attr">&quot;attitudes_count&quot;</span>: <span class="number">785</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;4893410513127118&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;mid&quot;</span>: <span class="string">&quot;4893410513127118&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;weibo_link&quot;</span>: <span class="string">&quot;https://weibo.com/2803301701/MDc27d7vo&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;第54个世界地球日，江豚回家路还有多远...&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;publish_time&quot;</span>: <span class="string">&quot;2023-04-22 19:37:24&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;user_link&quot;</span>: <span class="string">&quot;https://weibo.com/u/2803301701&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;user_name&quot;</span>: <span class="string">&quot;人民日报&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reposts_count&quot;</span>: <span class="number">119</span>,</span><br><span class="line">    <span class="attr">&quot;comments_count&quot;</span>: <span class="number">145</span>,</span><br><span class="line">    <span class="attr">&quot;attitudes_count&quot;</span>: <span class="number">463</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在要转成下面这样的 csv：</p><table><thead><tr><th>mid</th><th>weibo_link</th><th>text</th><th>publish_time</th><th>user_link</th><th>user_name</th><th>reposts_count</th><th>comments_count</th><th>attitudes_count</th></tr></thead><tbody><tr><td>4893424946515214</td><td><a href="https://weibo.com/2803301701/MDcporkU6">https://weibo.com/2803301701/MDcporkU6</a></td><td>据悉，全城月季花已逐渐进入盛花期。</td><td>2023-04-22 20:34:45</td><td><a href="https://weibo.com/u/2803301701">https://weibo.com/u/2803301701</a></td><td>人民日报</td><td>55</td><td>92</td><td>298</td></tr><tr><td>4893416880346795</td><td><a href="https://weibo.com/2803301701/MDcco1sdt">https://weibo.com/2803301701/MDcco1sdt</a></td><td>4月22日，陕西西安。游客发视频…</td><td>2023-04-22 20:02:42</td><td><a href="https://weibo.com/u/2803301701">https://weibo.com/u/2803301701</a></td><td>人民日报</td><td>119</td><td>249</td><td>785</td></tr><tr><td>4893410513127118</td><td><a href="https://weibo.com/2803301701/MDc27d7vo">https://weibo.com/2803301701/MDc27d7vo</a></td><td>第54个世界地球日，江豚回家路还有多远…</td><td>2023-04-22 19:37:24</td><td><a href="https://weibo.com/u/2803301701">https://weibo.com/u/2803301701</a></td><td>人民日报</td><td>119</td><td>145</td><td>463</td></tr></tbody></table><p>只需要运行下面这份代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># author:           inspurer(月小水长)</span></span><br><span class="line"><span class="comment"># create_time:      2023/4/22 20:49</span></span><br><span class="line"><span class="comment"># 运行环境           Python3.6+</span></span><br><span class="line"><span class="comment"># github            https://github.com/inspurer</span></span><br><span class="line"><span class="comment"># website           https://buyixiao.github.io/</span></span><br><span class="line"><span class="comment"># 微信公众号         月小水长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_json_to_csv</span>(<span class="params">input_json_path, output_csv_path</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_json_path, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        input_json = json.loads(f.read())</span><br><span class="line"></span><br><span class="line">    data_list = []</span><br><span class="line"></span><br><span class="line">    data_cols = input_json[<span class="built_in">list</span>(input_json.keys())[<span class="number">0</span>]].keys()</span><br><span class="line">    <span class="keyword">for</span> a_weibo <span class="keyword">in</span> input_json.values():</span><br><span class="line">        data_list.append(<span class="built_in">list</span>(a_weibo.values()))</span><br><span class="line">    df = pd.DataFrame(data_list, columns=data_cols)</span><br><span class="line"></span><br><span class="line">    df.to_csv(output_csv_path, index=<span class="literal">False</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">convert_json_to_csv(<span class="string">&#x27;./data/2803301701.json&#x27;</span>, <span class="string">&#x27;./data/2803301701.csv&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码中没有指定 csv 的任何列名，自动从 json 文件中获取，具有一定的普适性。</p>]]></content>
    
    
    <summary type="html">无需指定 columns 转 json 成 csv，具有一定的普适性</summary>
    
    
    
    <category term="Python" scheme="https://buyixiao.github.io/categories/Python/"/>
    
    
    <category term="json" scheme="https://buyixiao.github.io/tags/json/"/>
    
    <category term="csv" scheme="https://buyixiao.github.io/tags/csv/"/>
    
    <category term="文件转换" scheme="https://buyixiao.github.io/tags/%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>pandas 缺失值的识别和处理</title>
    <link href="https://buyixiao.github.io/blog/pandas-na-tricks.html"/>
    <id>https://buyixiao.github.io/blog/pandas-na-tricks.html</id>
    <published>2023-04-10T08:51:42.000Z</published>
    <updated>2023-04-10T09:25:58.148Z</updated>
    
    <content type="html"><![CDATA[<p> dataframe 中的缺失值非常常见，很有必要掌握精准识别和处理确实值的技巧。</p><h3 id="识别缺失值"><a href="#识别缺失值" class="headerlink" title="识别缺失值"></a>识别缺失值</h3><p>pandas 会将诸如 <code>NaN</code>、<code>null</code>、<code>None</code>、<code>NA</code> 等值视为缺失值，但是在实践中，类似 <code>init</code> 、<code>暂无</code>、<code>缺失</code> 等这样的值，我们也视为缺失值，怎么把这个认知喂给 pandas 呢，有两个办法。</p><p>第一种方法是在读取文件时，比如 <code>read_csv()</code>，有一个参数 <code>na_values</code>，它接受一个 list 列表，里面的每一个值就是我们要新增的缺失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;demo.csv&#x27;</span>,na_values=[<span class="string">&#x27;init&#x27;</span>,<span class="string">&#x27;暂无&#x27;</span>])</span><br></pre></td></tr></table></figure><p>第二个方法是读取文件后，使用 replace，如果有很多个，不可避免要使用 for 循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.replace(<span class="string">&#x27;init&#x27;</span>, np.nan, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h3><p>两种思路，一种是去除缺失值、另外一种是填充缺失值。</p><h4 id="去除缺失值"><a href="#去除缺失值" class="headerlink" title="去除缺失值"></a>去除缺失值</h4><p>dataframe 内置了这个方法 <code>dropna()</code> ，第一个参数 axis 是老生常谈的了，会经常遇到，简单来说 axis =0 （默认值）就是一行一行的处理，axis=1 就是一列一列的处理；第二个参数 inplace 更加常见，取值 False（默认值） 时返回修改后的 dataframe，取值 True 意即原地修改，也就没有返回值。最后一个参数 how 取值为 <code>all</code>、<code>any</code> 之一，前一个意思为如果这一行所有的 item 都是缺失值才去除，后者条件更加宽松：只有某一行有一个 item 是缺失值就去除。</p><h4 id="填充缺失值"><a href="#填充缺失值" class="headerlink" title="填充缺失值"></a>填充缺失值</h4><p>常见的填充方式也有两种，第一种是使用同列的平均值、或者中位数填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># price 列的缺失值用均值代替</span></span><br><span class="line">df.fillna(&#123;<span class="string">&#x27;price&#x27;</span>: df[<span class="string">&#x27;price&#x27;</span>].mean()&#125;)</span><br></pre></td></tr></table></figure><p>另外一种是在该列使用插值，此种方式更为优雅。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;price&#x27;</span>] = df[<span class="string">&#x27;price&#x27;</span>].interpolate(method=<span class="string">&#x27;linear&#x27;</span>)</span><br></pre></td></tr></table></figure><p>method 可以取值为：</p><ul><li><code>slinear</code>、<code>linear</code>：线性插值</li><li><code>nearest</code>：最邻近插值法</li><li>更多取值的可以参考官方文档</li></ul>]]></content>
    
    
    <summary type="html">精准识别和恰当处理 dataframe 中的缺失值的 tricks 分享</summary>
    
    
    
    <category term="Python" scheme="https://buyixiao.github.io/categories/Python/"/>
    
    
    <category term="pandas" scheme="https://buyixiao.github.io/tags/pandas/"/>
    
    <category term="NA" scheme="https://buyixiao.github.io/tags/NA/"/>
    
    <category term="interpolate" scheme="https://buyixiao.github.io/tags/interpolate/"/>
    
  </entry>
  
  <entry>
    <title>CBDB 历史人物关系和足迹可视化</title>
    <link href="https://buyixiao.github.io/blog/historical-figure-visual.html"/>
    <id>https://buyixiao.github.io/blog/historical-figure-visual.html</id>
    <published>2023-03-14T06:52:25.000Z</published>
    <updated>2023-03-14T07:09:37.438Z</updated>
    
    <content type="html"><![CDATA[<p>中国历代人物传记资料库（CBDB）是在社会学科领域有着鼎鼎大名，它系统性地收入了中国历史上所有重要的传记资料，其项目主页地址如下：</p><p><a href="https://projects.iq.harvard.edu/chinesecbdb">https://projects.iq.harvard.edu/chinesecbdb</a></p><p>我最开始接触到这个数据库还是我大二时候，然后那时我一无所能，面对这么庞大的数据库无从下手。等到后面学了数据库基本原理和技术，以及一点数据分析可视化技巧后，才陆陆续续有了一些可以实现的 idea，于是上周日完成了一些可能相对古早的 idea，一并部署上线，页面地址为：</p><p><a href="https://tools.buyixiao.xyz/historical-figure-query">https://tools.buyixiao.xyz/historical-figure-query</a></p><p>页面长这样，非常简洁。</p><p><img src="https://s2.loli.net/2023/03/14/9wuKHqrjS3ngibY.png"></p><p>页面功能概括如下：只需要输入一个历史人物名（CBDB 共收录 52w 余人），就能生成该人物的社会关系图、亲属关系图以及此人在华夏大地留下的足迹图。</p><p>人海浮沉几万里，此心安处是吾乡，苏东坡的一生，几乎都是在漂泊中度过的。下文将用今天分享的工具，从一个小角度看见大才子。</p><p>在页面上输入苏轼并回车，可得：</p><p><img src="https://s2.loli.net/2023/03/14/7wod2tv3h5xIe9z.png"></p><p>​        苏轼，男，宋朝人，生于公元 1036 年，卒于公元 1101 年，享年 66 岁。</p><p><img src="https://s2.loli.net/2023/03/14/bjIDNFRzM58rum7.png"></p><p>苏轼的社会关系（包括敌人、朋友等等）非常复杂，大部分是诗文雅趣之事，也有惨遭小人攻讦之难。</p><p><img src="https://s2.loli.net/2023/03/14/eN7PkOy3MgxpujE.png"></p><p>相比较之下，苏轼的亲属关系就显得简单许多，这大概和传记对其家人（可能苏洵、苏辙除外）记载并不多。</p><p><img src="https://s2.loli.net/2023/03/14/guAbIxZ5SVw6cz9.png"></p><p>苏轼是四川眉山人，出生于 1036 年，在 1056 年以前，也就是他人生的前二十年，几乎都是在巴山夜雨中度过的，然后前往北宋都城开封应试，遇见伯乐欧阳修，就在他名动京师之时，母亲去世，苏轼携本家一大一小二苏回川奔丧，守丧期满后至凤翔府做官。（如果前往网页，上面的地图可放大缩小，这些旅程可以看得很清）</p><p>因和主持变法的王安石政见不和，自请出任杭州通判，江南风月好哇，于是就有了欲把西湖比西子，有了苏堤春晓、三潭映月，还有那令人垂涎三尺的东坡肉。（按史实考，实际上修浚西湖是他再任杭州时的政绩）</p><p>苏轼说，”古之成大事者，不唯有超世之才，亦必有坚韧不拔之志“，诚不我欺，乌台诗案给予了苏轼沉重打击，被迫下放黄州团练副使，楚水本是凄凉地，触景伤情，可是苏东坡是谁哇，在赤壁古战场，他惊叹，”此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍“；”酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？“，他豁然；”寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风“，他哀伤。当然，他也自嘲，“但少闲人如吾两人耳。”</p><p>毛色日益衰，志气日益微呐，五十九岁的大才子还要被连贬至惠州，岭南何许地也，屈原笔下的莽荒之地，可是此心安处即是他苏东坡的乡，“日啖荔枝三百颗，不辞长作岭南人。”大快朵颐，岂不美哉？值得一提是，苏轼同样给惠州人民带了一个西湖，同为 5A 景区，世人只知杭州西湖，却不知惠州西湖。</p><p>心似浮萍，台海波摇呐，花甲老人被再贬至更偏僻的儋州，孤岛夜月，何其凄怆？可他是筚路蓝缕人。</p><blockquote><p>摘自百度百科：苏轼把儋州当成了自己的第二故乡，“我本儋耳氏，寄生西蜀州”。他在这里办学堂，介学风，以致许多人不远千里，追至儋州，从苏轼学。在宋代一百多年里，海南从没有人进士及第。但苏轼北归不久，这里的姜唐佐就举乡贡。为此苏轼题诗：“沧海何曾断地脉，珠崖从此破天荒。”人们一直把苏轼看作是儋州文化的开拓者、播种人，对他怀有深深的崇敬。</p></blockquote><p>宋徽宗大赦天下，苏轼北归，途经廉州、永州，于 公元1101 年病逝于常州，上述地图中北归旅程清晰可见。</p><p>好的，走远了，这其实是一篇野生的技术文。本文只是以苏轼为例，可以在页面上输入任何历史名人，欢迎大家访问工具页面，复制下述地址到浏览器打开或者点击<a href="https://tools.buyixiao.xyz/historical-figure-query">阅读原文</a>（如果访问不了那就是服务器过载了，稍等就好）</p><p><a href="https://tools.buyixiao.xyz/historical-figure-query">https://tools.buyixiao.xyz/historical-figure-query</a></p>]]></content>
    
    
    <summary type="html">笔者基于 CBDB 数据库开发了一个可视化历史人物的社会关系、亲属关系和人生足迹的网页，「人海浮沉几万里，此心安处是吾乡」，以苏轼为例。</summary>
    
    
    
    <category term="可视化" scheme="https://buyixiao.github.io/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
    <category term="可视化" scheme="https://buyixiao.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="CBDB" scheme="https://buyixiao.github.io/tags/CBDB/"/>
    
    <category term="历史人物" scheme="https://buyixiao.github.io/tags/%E5%8E%86%E5%8F%B2%E4%BA%BA%E7%89%A9/"/>
    
    <category term="关系网络" scheme="https://buyixiao.github.io/tags/%E5%85%B3%E7%B3%BB%E7%BD%91%E7%BB%9C/"/>
    
    <category term="生平足迹" scheme="https://buyixiao.github.io/tags/%E7%94%9F%E5%B9%B3%E8%B6%B3%E8%BF%B9/"/>
    
  </entry>
  
  <entry>
    <title>pandas 拆分具有相同结构的 csv</title>
    <link href="https://buyixiao.github.io/blog/split-csv-with-same-columns.html"/>
    <id>https://buyixiao.github.io/blog/split-csv-with-same-columns.html</id>
    <published>2023-03-08T14:47:08.000Z</published>
    <updated>2023-03-08T14:59:50.929Z</updated>
    
    <content type="html"><![CDATA[<p>在教程 <a href="https://buyixiao.github.io/blog/merge-csv-with-same-columns.html">pandas 合并具有相同结构的 csv</a> 中，我们分享了如何将一个文件夹下很多具有相同结构的 csv 文件合并为一个总的 csv 文件的代码，今天分享的是如何从这个总的 csv 文件还原成原来的一堆子文件，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># author:           inspurer(月小水长)</span></span><br><span class="line"><span class="comment"># create_time:      2022/8/16 14:07</span></span><br><span class="line"><span class="comment"># 运行环境           Python3.6+</span></span><br><span class="line"><span class="comment"># github            https://github.com/inspurer</span></span><br><span class="line"><span class="comment"># website           https://buyixiao.github.io/</span></span><br><span class="line"><span class="comment"># 微信公众号         月小水长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">input_file = <span class="string">&#x27;all.csv&#x27;</span></span><br><span class="line"></span><br><span class="line">output_folder = <span class="string">&#x27;result&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_folder):</span><br><span class="line">    os.mkdir(output_folder)</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(input_file, float_precision=<span class="string">&#x27;round-trip&#x27;</span>)</span><br><span class="line">groups = df.groupby(df[<span class="string">&#x27;origin_file_name&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> group <span class="keyword">in</span> groups:</span><br><span class="line">    group[<span class="number">1</span>].drop(<span class="string">&#x27;origin_file_name&#x27;</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    group[<span class="number">1</span>].to_csv(os.path.join(output_folder, <span class="string">&#x27;&#123;&#125;.csv&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(group[<span class="number">0</span>]))), index=<span class="literal">False</span>,</span><br><span class="line">                    encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如有错误欢迎指正，如有更优解决方案请赐教~</p>]]></content>
    
    
    <summary type="html">本系列教程【合并具有相同结构的 csv】的逆过程</summary>
    
    
    
    <category term="Python" scheme="https://buyixiao.github.io/categories/Python/"/>
    
    
    <category term="pandas" scheme="https://buyixiao.github.io/tags/pandas/"/>
    
    <category term="csv 拆分" scheme="https://buyixiao.github.io/tags/csv-%E6%8B%86%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【动态规划】刷题记录</title>
    <link href="https://buyixiao.github.io/blog/dynamic-programming-notes.html"/>
    <id>https://buyixiao.github.io/blog/dynamic-programming-notes.html</id>
    <published>2023-02-28T12:51:37.000Z</published>
    <updated>2023-03-01T08:00:55.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h3><p>百度百科解释如下：</p><blockquote><p>动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。<br>动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。<br>基本思想与策略编辑:<br>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p></blockquote><p>一篇动态规划 <a href="https://blog.csdn.net/ailaojie/article/details/83014821">博客</a> 阐述如下：</p><blockquote><p>首先是拆分问题，根据问题的可能性把问题划分成一步一步，这样就可以通过递推或者递归来实现.<br>关键就是这个步骤，动态规划有一类问题就是从后往前推到，有时候我们很容易知道:如果只有一种情况时，最佳的选择应该怎么做。然后根据这个最佳选择往前一步推导，得到前一步的最佳选择<br>然后就是定义问题状态和状态之间的关系，我的理解是前面拆分的步骤之间的关系，用一种量化的形式表现出来，类似于高中学的推导公式,因为这种式子很容易用程序写出来，也可以说对程序比较亲和(也就是最后所说的状态转移方程式)<br>我们再来看定义的下面的两段，我的理解是比如我们找到最优解,我们应该讲最优解保存下来，为了往前推导时能够使用前一步的最优解,在这个过程中难免有一些相比于最优解差的解，此时我们应该放弃，只保存最优解，这样我们每一次都把最优解保存了下来，大大降低了时间复杂度。</p></blockquote><p>动态规划与分治法的区别在于划分的子问题是有重叠的，解过程中对于重叠的部分只要求解一次，记录下结果，减少了重复计算过程。<br>另外，DP在求解一个问题最优解时，不是固定的计算合并某些子问题的解，而是根据各子问题的解的情况选择其中最优的。<br>动态规划求解具有以下性质：<br>最优子结构性质：最优解包含了其子问题的最优解，不是合并所有子问题的解，而是找最优的一条解线路，选择部分子最优解来达到最终的最优解。<br>子问题重叠性质：先计算子问题的解，再由子问题的解去构造问题的解（由于子问题存在重叠，把子问题解记录下来为下一步使用，这样就可以从备忘录中读取）。其中备忘录先记录初始状态。</p><h3 id="刷题记录"><a href="#刷题记录" class="headerlink" title="刷题记录"></a>刷题记录</h3><h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p>LeetCode 链接：<a href="https://leetcode.cn/problems/longest-increasing-subsequence">https://leetcode.cn/problems/longest-increasing-subsequence</a></p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>令状态 dp[i] 表示以 nums[i] 作为末尾的最长递增子序列的长度，考虑边界情况，dp[0] = 1，状态转移方程  <code>dp[i] = max(dp[j]) +1，其中 0&lt;=j&lt;i 且 num[j]&lt;num[i]</code> ，考虑在 j = 0…i-1 取一个最大子序列长度时，因为要求 num[i]  结尾，序列要求递增，则必须 num[i] &gt; num[j]。</p><p>最后，整个数组的最长上升子序列即 dp 数组的最大值。</p><h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        dp.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> dp_max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    temp = <span class="built_in">max</span>(temp, dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            dp_max = <span class="built_in">max</span>(dp_max, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p>LeetCode 链接：<a href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></p><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>令状态 dp[i] 表示以 nums[i] 作为末尾的连续序列的最大和，考虑边界情况，dp[0] = nums[0]，状态转移方程  dp[i] = max(nums[i], dp[i-1] + nums[i])，因为是以 nums[i] 结尾，max 的作用其实就是取舍上一个状态，如果上一个状态小于等于 0，dp[i] = nums[i]。</p><p>求 dp[i] 的同时可以做比较，避免二次循环。</p><h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        dp.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> dp_max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp.<span class="built_in">push_back</span>(<span class="built_in">max</span>(nums[i], nums[i]+ dp[i<span class="number">-1</span>]));</span><br><span class="line">            <span class="keyword">if</span>(dp_max &lt; dp[i])&#123;</span><br><span class="line">                dp_max = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>LeetCode 链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock</a></p><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。</p><p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。</p><p>LeetCode-Solution 链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/</a></p><h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_v = prices[<span class="number">0</span>], max_b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            max_b = <span class="built_in">max</span>(max_b, prices[i] - min_v);</span><br><span class="line">            min_v = <span class="built_in">min</span>(min_v, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="卖股票的最佳时机-II"><a href="#卖股票的最佳时机-II" class="headerlink" title="卖股票的最佳时机 II"></a>卖股票的最佳时机 II</h4><p>直接参考：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/</a></p><h4 id="UVA-12034-Race"><a href="#UVA-12034-Race" class="headerlink" title="UVA 12034 Race"></a>UVA 12034 Race</h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>n 匹马，共有多少种排名情况（可以并列）</p><p>UVA 链接：<a href="https://vjudge.net/problem/UVA-12034">https://vjudge.net/problem/UVA-12034</a></p><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>参考链接：<a href="https://blog.csdn.net/qq_39479426/article/details/81229724">https://blog.csdn.net/qq_39479426/article/details/81229724</a></p><p><code>dp[i][j]</code> 表示 i 匹马占有 j 个名次的组合情况</p><p>然后考虑 i 匹马和 i-1 匹马的转移关系，多了一匹马要放在哪个位置，有下面两种情况</p><p>第 i 匹马和前 i-1 匹马中至少一匹马的成绩相同（j 个名次就有 j 种情况）<br>这匹马独占了一个成绩（可以放入 j 个位置，注意这里不是 j+1）<br>所以可以得到递推式：<code>dp[i][j] = dp[i-1][j] * j + dp[i-1][j-1] * j</code></p><h5 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">1050</span>][<span class="number">1050</span>];   <span class="comment">//dp[i][j]表示i只马占有j个名次(i&gt;=j)</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> fac[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    # 求阶乘，i == j = A 时，组合情况就是 A！</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">        fac[i] = (i * fac[i - <span class="number">1</span>]) % <span class="number">10056</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= j)</span><br><span class="line">            <span class="comment">//前i-1只马用完了j个名次,最后一只马有j种选择; 前面i-1只马用了j-1个名次,(j-1)最后一只马独占一个名次,同样有j种选择</span></span><br><span class="line">                dp[i][j] = (dp[i - <span class="number">1</span>][j] * j + dp[i - <span class="number">1</span>][j - <span class="number">1</span>] * j) % <span class="number">10056</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == j)</span><br><span class="line">                dp[i][j] = fac[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            sum = (sum + dp[n][i]) % <span class="number">10056</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %lld\n&quot;</span>, k++, sum);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0/1 背包问题"></a>0/1 背包问题</h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>给定 n 种物品和一个容量为 C 的背包，物品 i 的重量是 wi，其价值为 vi。问：应该如何选择装入背包的物品，使得装入背包中的物品的总价值最大？</p><h5 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//记忆性数组动态规划解法 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">packageSolution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> pc, <span class="keyword">int</span> gvol[], <span class="keyword">int</span> gval[])</span></span>&#123;</span><br><span class="line"><span class="comment">//用 dp[i][j] 表示，取前 i 种物品，总体积不超过 j 的所能取得的最大价值总量 </span></span><br><span class="line"><span class="keyword">int</span> dp[n+<span class="number">1</span>][pc+<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 初始化边界条件，也就是第一行，取前 1 种物品，总体积不超过 j 的最大价值总量 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= pc; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(gvol[<span class="number">1</span>]&lt;=j) &#123;</span><br><span class="line">dp[<span class="number">1</span>][j] = gval[<span class="number">1</span>];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[<span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt;= pc; j++)&#123;</span><br><span class="line"><span class="comment">// dp[i-1][j] 表示不取第 i 种物品的最大价值</span></span><br><span class="line"><span class="comment">// dp[i-1][j-gvol[i]] + gval[i] 表示取第 i 种物品的最大价值，认真想一下 dp[i][j] i、j 分别表示啥意思，就知道为啥需要 dp[i][j-gvol[i]] 了，体会状态转化的思想</span></span><br><span class="line"><span class="comment">// 只有  (j - gvol[i])&gt;=0 才能取第 i 种 </span></span><br><span class="line"><span class="keyword">if</span>((j - gvol[i])&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-gvol[i]] + gval[i]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][pc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//物品个数，背包容量 </span></span><br><span class="line"><span class="keyword">int</span> n, package_capacity;</span><br><span class="line"><span class="comment">//输入一行，两个数字以空格间隔 </span></span><br><span class="line">cin&gt;&gt;n&gt;&gt;package_capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">//物品体积数组、物品价值数组 </span></span><br><span class="line"><span class="keyword">int</span> goods_volumn[n+<span class="number">1</span>], goods_value[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="comment">//输入 n 行，每行两个数字以空格间隔 </span></span><br><span class="line">cin&gt;&gt;goods_volumn[i]&gt;&gt;goods_value[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以 3 个物体，背包容量为 5 为例</span></span><br><span class="line"><span class="comment">//三个物体的体积、价值依次是</span></span><br><span class="line"><span class="comment">//1 3 </span></span><br><span class="line"><span class="comment">//2 1</span></span><br><span class="line"><span class="comment">//3 2 </span></span><br><span class="line"><span class="comment">// 那么会选择第一个和第三个物品，最大价值和为 3+2=5 </span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;the max total value: &quot;</span>&lt;&lt;<span class="built_in">packageSolution</span>(n, package_capacity, goods_volumn, goods_value);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考材料"><a href="#参考材料" class="headerlink" title="参考材料"></a>参考材料</h3><p>1、北京大学郭炜 MOOC 慕课：<a href="https://www.icourse163.org/learn/PKU-1001894005">https://www.icourse163.org/learn/PKU-1001894005</a></p>]]></content>
    
    
    <summary type="html">动态规划（dynamic programming）算法刷题笔记</summary>
    
    
    
    <category term="算法笔记" scheme="https://buyixiao.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法" scheme="https://buyixiao.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://buyixiao.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>塞缪尔·厄尔曼：青春</title>
    <link href="https://buyixiao.github.io/blog/youth-by-samuel-ullman.html"/>
    <id>https://buyixiao.github.io/blog/youth-by-samuel-ullman.html</id>
    <published>2023-02-04T08:56:14.000Z</published>
    <updated>2023-02-04T09:11:14.079Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《青春》作者是德裔美国作家塞缪尔·厄尔曼。</p></blockquote><h2 id="中文译文"><a href="#中文译文" class="headerlink" title="中文译文"></a>中文译文</h2><p>青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志、恢宏的想象、炽热的感情；青春是生命的深泉在涌流。</p><p>青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生有之，六旬男子则更多见。年岁有加，并非垂老；理想丢弃，方堕暮年。岁月悠悠，衰微只及肌肤；热忱抛却，颓唐必致灵魂。忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。</p><p>无论年届花甲，抑或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。</p><p>人人心中皆有一台天线，只要你从天上人间接受美好、希望、欢乐、勇气和力量的信号，你无不青春永驻、风华长存。</p><p>一旦天线降下，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即便年方二十，实已垂垂老矣；然则只要竖起天线，捕捉乐观信号，你就有望在八十高龄告别尘寰时仍觉年轻。</p><h2 id="英文原文"><a href="#英文原文" class="headerlink" title="英文原文"></a>英文原文</h2><p>《YOUTH 》 by Samuel Ullman</p><p>Youth is not a time of life; it is a state of mind; it is not a matter of rosy cheeks, red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions; it is the freshness of the deep springs of life.</p><p>Youth means a temperamental predominance of courage over timidity of the appetite, for adventure over the love of ease. This often exists in a man of sixty more than a boy of twenty. Nobody grows old merely by a number of years. We grow old by deserting our ideals.</p><p>Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul. Worry, fear, self-distrust bows the heart and turns the spirit back to dust.</p><p>Whether sixty or sixteen, there is in every human being’s heart the lure of wonder, the unfailing child-like appetite of what’s next, and the joy of the game of living. In the center of your heart and my heart there is a wireless station; so long as it receives messages of beauty, hope, cheer, courage and power from men and from the infinite, so long are you young.</p><p>When the aerials are down, and your spirit is covered with snows of cynicism and the ice of pessimism, then you are grown old, even at twenty, but as long as your aerials are up, to catch the waves of optimism, there is hope you may die young at eighty.</p>]]></content>
    
    
    <summary type="html">青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。</summary>
    
    
    
    <category term="励志" scheme="https://buyixiao.github.io/categories/%E5%8A%B1%E5%BF%97/"/>
    
    
    <category term="青春" scheme="https://buyixiao.github.io/tags/%E9%9D%92%E6%98%A5/"/>
    
  </entry>
  
  <entry>
    <title>crontab 定时执行 Python 脚本踩坑记录</title>
    <link href="https://buyixiao.github.io/blog/crontab-python.html"/>
    <id>https://buyixiao.github.io/blog/crontab-python.html</id>
    <published>2023-02-04T07:28:38.000Z</published>
    <updated>2023-02-04T08:48:57.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>换过几个云服务器，每次都要在 crontab 这折腾一会儿，这次索性把问题记录下来，力求详尽。</p><p>笔者的云服务器：腾讯云 2C4G；</p><p>Linux 系统： Ubuntu 20.04 LTS 64bit。</p><blockquote><p>crontab 是 Linux 下周期性执行的指令，常常在后台运行，每一分钟检查是否有预定的作业需要执行。这类作业一般称为 cron jobs。(摘自百度百科)</p></blockquote><h3 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h3><p>1、cron 的配置文件可在三个地方存放</p><ul><li><code>/var/spool/cron/crontabs/root</code></li><li><code>/etc/crontab</code></li><li><code>/etc/cron.d/</code></li></ul><p>​      一般情况下，通过 crontab -e 命令编辑的是第一个路径下的配置文件，在这里的命令不需要指定用户为 root；后两个则需要，比如命令 <code> 0 3 * * 1 root python test.py</code>，其中的 root 不可少。</p><p>需要注意的是，如果使用 crontab -e 编辑，修改后使用 Ctrl+X，提示：<code>save modified buffer ...?</code>    ，选择 ：yes，又提示：<code>file name to write</code> ，选择：Ctrl+T，在最后一个界面使用左右箭头切换至 crontab。</p><p>2、虽然说编辑完 crontab 文件后不需要重启 cron 服务，但是包括重启在内的一些命令最好还是了解下。</p><ul><li>重启，各种资料都说是 service crond restart，在笔者的环境上实测是 service cron restart；在 centos 上是 systemctl restart crond，笔者暂未考证。</li><li>状态，笔者亲测为 service cron start；其他环境同上。</li></ul><h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><p>使用命令定时执行 python 脚本，每个小时的第 15 分钟运行一次，无任何反应。命令如下：</p><p><code>15 * * * * /mypath/venv/bin/python3 /mypath/monitor.py &gt;&gt; /mypath/execute.log 2&gt;&amp;1</code></p><p>python 脚本输出的 execute.log 亦无输出。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>第一步想着查看 crontab 的日志，才知道默认是不打开的需要手动配置。命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/rsyslog.d/50-default.conf</span><br><span class="line">cron.*  /var/log/cron.log #将cron前面的注释符去掉</span><br><span class="line"><span class="meta">#</span><span class="bash">重启rsyslog</span></span><br><span class="line">sudo service rsyslog restart</span><br><span class="line">sudo service cron restart</span><br></pre></td></tr></table></figure><p>然后 <code>vi /var/log/cron.log</code> 查看日志，能够发现脚本确实运行了，除此之外没有任何有用信息，看其他博主（参考文末链接2）说是需要安装 postfix，正安装着不知道怎么配置邮件服务器的域名，又看到如果 python 脚本输出配置了重定向日志，不用配这个也行。遂作罢。</p><p>排除了 crontab 的问题，那只有是 python 脚本的问题了，偶然间发现（参考文末链接 3）：python 脚本中涉及到读写文件的动作，一般定时任务都不会执行.；脚本在执行时，由于是通过 crontab 去执行的，它的执行目录会变成当前用户的根目录，如果是root，就会在/root/下执行。</p><p>但是我们读写的文件路径在 root 下吗，大概率不是，一种解决办法是将 python 脚本中的文件路径全部换成服务器绝对路径，但是这样可移植性差；更好的办法是使用 shell 脚本，shell 脚本第一行使用命令 cd 到我们的目的路径，然后第二行修改我们原来的命令（py 脚本的绝对路径也可以简化成相对路径），如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">！/usr/bin/bash</span></span><br><span class="line">cd /mypath</span><br><span class="line">/mypath/venv/bin/python3 /monitor.py </span><br></pre></td></tr></table></figure><p>使用 <code>chmod a+x test.sh</code> 赋予执行权限，然后在 crontab 配置定时运行这个 shell 脚本，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15 * * * * /bin/sh /mypath/test.sh &gt;&gt; /mypath/execute.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>最后可能还有一个坑，查看 execute.log，发现无法 cd 到 mypath，这是因为这个 test.sh 是通过 rz 上传的，不是在服务器上通过 touch 创建的，无法识别，解决办法就在原因中，touch 创建再复制命令就行。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1、<a href="https://blog.tankywoo.com/2014/10/05/the-holes-of-crontab.html">一个 crontab 的坑</a></p><p>2、<a href="https://my.oschina.net/leejun2005/blog/1788342">迷之 crontab 异常：不运行、不报错、无日志</a></p><p>3、<a href="https://blog.csdn.net/xys2333/article/details/112469461">crontab运行python脚本不生效问题</a></p>]]></content>
    
    
    <summary type="html">根治 crontab 运行 python 脚本的疑难杂症</summary>
    
    
    
    <category term="Linux" scheme="https://buyixiao.github.io/categories/Linux/"/>
    
    
    <category term="python" scheme="https://buyixiao.github.io/tags/python/"/>
    
    <category term="crontab" scheme="https://buyixiao.github.io/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>pandas groupby filter 函数妙用</title>
    <link href="https://buyixiao.github.io/blog/pandas-groupby-filter.html"/>
    <id>https://buyixiao.github.io/blog/pandas-groupby-filter.html</id>
    <published>2023-01-07T02:26:53.000Z</published>
    <updated>2023-01-08T07:00:14.783Z</updated>
    
    <content type="html"><![CDATA[<p>假设有一个狂人日记的 dataframe 如下：</p><table><thead><tr><th align="center">user_name</th><th align="center">publish_time</th><th align="center">content</th></tr></thead><tbody><tr><td align="center">小明</td><td align="center">2022-12-30 15:10:00</td><td align="center">今天是 2022 年最后一天，我在广东</td></tr><tr><td align="center">小刚</td><td align="center">2022-01-01 12:23:33</td><td align="center">今天是 2022 年第一天，我在加勒比</td></tr><tr><td align="center">小王</td><td align="center">2022-01-01 12:33:00</td><td align="center">今天是 2022 年第一天，我在小刚身边</td></tr><tr><td align="center">小刚</td><td align="center">2023-01-01 02:15:45</td><td align="center">今天是 2023 年第一天，我在百慕大</td></tr><tr><td align="center">小明</td><td align="center">2023-01-01 00:05:20</td><td align="center">今天是 2023 年第一天，我还在广东</td></tr></tbody></table><p>现在我们要统计狂人日记里面，同一作者第一次和最后一次发布时间差大于 30 天的行。</p><p>乍一看，首先必须统计同一作者至少发布两次的行，也就是上一篇<a href="https://buyixiao.github.io/blog/pandas-value-counts.html">value counts</a> 的内容。</p><p>然后再使用 groupby 分组 + filter 过滤实现，这个 filter 相当于 mysql 语句中 groupby 后的 having 语句，是在分组上做筛选的。</p><p>所以在上一篇的基础上，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># author:           inspurer(月小水长)</span></span><br><span class="line"><span class="comment"># create_time:      2023/1/7 8:58</span></span><br><span class="line"><span class="comment"># 运行环境           Python3.6+</span></span><br><span class="line"><span class="comment"># github            https://github.com/inspurer</span></span><br><span class="line"><span class="comment"># website           https://buyixiao.github.io/</span></span><br><span class="line"><span class="comment"># 微信公众号         月小水长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">input_file = <span class="string">&#x27;./狂人日记 2022.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_show_count_below_n</span>(<span class="params">input_file, col, n=<span class="number">2</span></span>):</span></span><br><span class="line">    df = pd.read_csv(input_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一步，筛选 user_name 出现大于等于 2 次的行</span></span><br><span class="line">    count_df = pd.DataFrame(df[col].value_counts())</span><br><span class="line">    count_df.columns = [<span class="string">&#x27;count&#x27;</span>]</span><br><span class="line">    not_below_n_index = count_df[count_df[<span class="string">&#x27;count&#x27;</span>] &gt;= n].index</span><br><span class="line">    df = df[df[col].isin(not_below_n_index)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 比上一篇新加的內容</span></span><br><span class="line">    df[<span class="string">&#x27;publish_date&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;publish_time&#x27;</span>]).dt.date</span><br><span class="line">    df = df.groupby(col).<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: (x[<span class="string">&#x27;publish_date&#x27;</span>].<span class="built_in">max</span>() - x[<span class="string">&#x27;publish_date&#x27;</span>].<span class="built_in">min</span>()).days &gt; <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    df.to_csv(<span class="string">&#x27;result.csv&#x27;</span>, index=<span class="literal">False</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>)</span><br><span class="line"></span><br><span class="line">remove_show_count_below_n(input_file, col=<span class="string">&#x27;user_name&#x27;</span>)</span><br></pre></td></tr></table></figure><p>仔细想想，第一步真的有必要吗？如果只出现一次，在第二步 publish_date 相减的时候差值为 0，直接就过滤掉了，所以第一步在这个任务是多此一举。简化代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_interval_filter</span>(<span class="params">input_file, col, days</span>):</span></span><br><span class="line">    df = pd.read_csv(input_file)</span><br><span class="line">    df[<span class="string">&#x27;publish_date&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;publish_time&#x27;</span>]).dt.date</span><br><span class="line">    df = df.groupby(col).<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: (x[<span class="string">&#x27;publish_date&#x27;</span>].<span class="built_in">max</span>() - x[<span class="string">&#x27;publish_date&#x27;</span>].<span class="built_in">min</span>()).days &gt; days)</span><br><span class="line">    df.to_csv(<span class="string">&#x27;result.csv&#x27;</span>, index=<span class="literal">False</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>)</span><br><span class="line"></span><br><span class="line">time_interval_filter(input_file, col=<span class="string">&#x27;user_name&#x27;</span>, days=<span class="number">30</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">筛选出两次时间差大于任意时间的内容</summary>
    
    
    
    <category term="Python" scheme="https://buyixiao.github.io/categories/Python/"/>
    
    
    <category term="filter" scheme="https://buyixiao.github.io/tags/filter/"/>
    
    <category term="groupby" scheme="https://buyixiao.github.io/tags/groupby/"/>
    
    <category term="pandas" scheme="https://buyixiao.github.io/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>pandas 筛选某列值出现至少 N 次的行</title>
    <link href="https://buyixiao.github.io/blog/pandas-value-counts.html"/>
    <id>https://buyixiao.github.io/blog/pandas-value-counts.html</id>
    <published>2023-01-07T01:59:51.000Z</published>
    <updated>2023-01-08T06:59:02.854Z</updated>
    
    <content type="html"><![CDATA[<p>假设有一个 dataframe 如下：</p><table><thead><tr><th align="center">user_name</th><th align="center">publish_time</th><th align="center">content</th></tr></thead><tbody><tr><td align="center">小明</td><td align="center">2022-12-30 15:10:00</td><td align="center">今天是 2022 年最后一天，我在广东</td></tr><tr><td align="center">小刚</td><td align="center">2022-01-01 12:23:33</td><td align="center">今天是 2022 年第一天，我在加勒比</td></tr><tr><td align="center">小王</td><td align="center">2022-01-01 12:33:00</td><td align="center">今天是 2022 年第一天，我在小刚身边</td></tr><tr><td align="center">小刚</td><td align="center">2023-01-01 02:15:45</td><td align="center">今天是 2023 年第一天，我在百慕大</td></tr><tr><td align="center">小明</td><td align="center">2023-01-01 00:05:20</td><td align="center">今天是 2023 年第一天，我还在广东</td></tr></tbody></table><p>现在我们要统计 user_name 中出现两次及以上的行。肉眼可以看出就是小明、小刚各自两行共四行。</p><p>最开始我的思路是使用 drop_duplicated 按照 user_name 为 key 去重，将去重后的 dataframe 和原来的 dataframe 按照所有列为 key 合并后再去重，这样一来就只剩下 user_name 出现两次及以上的行了，但是这种思路扩展性不好，假如是出现  3 次及以上呢？计算量就更大了。</p><p>改进后的思路是：主要使用 pandas 的 value_counts 函数统计次数，isin 函数实现筛选，其代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># author:           inspurer(月小水长)</span></span><br><span class="line"><span class="comment"># create_time:      2023/1/7 8:58</span></span><br><span class="line"><span class="comment"># 运行环境           Python3.6+</span></span><br><span class="line"><span class="comment"># github            https://github.com/inspurer</span></span><br><span class="line"><span class="comment"># website           https://buyixiao.github.io/</span></span><br><span class="line"><span class="comment"># 微信公众号         月小水长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">input_file = <span class="string">&#x27;./狂人日记 2022.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_show_count_below_n</span>(<span class="params">input_file, col, n=<span class="number">2</span></span>):</span></span><br><span class="line">    df = pd.read_csv(input_file)</span><br><span class="line"></span><br><span class="line">    count_df = pd.DataFrame(df[col].value_counts())</span><br><span class="line">    count_df.columns = [<span class="string">&#x27;count&#x27;</span>]</span><br><span class="line">    not_below_n_index = count_df[count_df[<span class="string">&#x27;count&#x27;</span>] &gt;= n].index</span><br><span class="line">    df = df[df[col].isin(not_below_n_index)]</span><br><span class="line"></span><br><span class="line">    df.to_csv(<span class="string">&#x27;result.csv&#x27;</span>, index=<span class="literal">False</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>)</span><br><span class="line"></span><br><span class="line">remove_show_count_below_n(input_file, col=<span class="string">&#x27;user_name&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如有更优雅的方式（肯定有），请批评指正～</p>]]></content>
    
    
    <summary type="html">不用 groupby，使用 value_counts 统计次数</summary>
    
    
    
    <category term="Python" scheme="https://buyixiao.github.io/categories/Python/"/>
    
    
    <category term="pandas" scheme="https://buyixiao.github.io/tags/pandas/"/>
    
    <category term="frequency" scheme="https://buyixiao.github.io/tags/frequency/"/>
    
    <category term="value_counts" scheme="https://buyixiao.github.io/tags/value-counts/"/>
    
  </entry>
  
  <entry>
    <title>android camera2 实战经验汇总</title>
    <link href="https://buyixiao.github.io/blog/android-camera2.html"/>
    <id>https://buyixiao.github.io/blog/android-camera2.html</id>
    <published>2022-06-04T15:07:44.000Z</published>
    <updated>2022-06-04T15:36:38.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="android-camera2-简单介绍"><a href="#android-camera2-简单介绍" class="headerlink" title="android camera2 简单介绍"></a>android camera2 简单介绍</h3><p>从 Android 5.0 开始，Google 引入了一套全新的相机框架 Camera2 api，它相比较 Camera1 有以下优势：</p><p>1、可以获取更多的帧(预览/拍照)信息以及手动控制每一帧的参数<br>2、对Camera的控制更加完全(比如支持调整focus distance, 剪裁预览/拍照图片)<br>3、支持更多图片格式(yuv/raw)以及高速连拍<br>4、…</p><p>现在是 2022 年了，可以说 99% 以上的安卓手机都在 5.0 系统，因此完全不用担心兼容问题。本文只是记录在自定义 camera2 实现连拍过程的坑，具体有关 camera2 的介绍可以参考 Google 的文档。</p><blockquote><p><a href="https://developer.android.com/training/camera2">https://developer.android.com/training/camera2</a></p></blockquote><h3 id="camera2-实现连拍并保存"><a href="#camera2-实现连拍并保存" class="headerlink" title="camera2 实现连拍并保存"></a>camera2 实现连拍并保存</h3><p>理论上 camera2 连拍可以达到 30fps，笔者需要的速度是 20s 拍 100 张并保存，实测无压力。主要是使用 CountDownTimer 定时 build CaptureRequest，然后在 CaptureResult 中使用 RxJava 线程调度，即在 IO 线程保存照片，在 UI 线程更新。</p><h3 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h3><h4 id="预览正常，保存的照片旋转了-90-度"><a href="#预览正常，保存的照片旋转了-90-度" class="headerlink" title="预览正常，保存的照片旋转了 90 度"></a>预览正常，保存的照片旋转了 90 度</h4><p>解决办法有两个，第一个就在在 CaptureRequest 中构建 bitmap，然后强行使这个 bitmap 旋转到原来的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">adjustPhotoRotation</span><span class="params">(Bitmap bm, <span class="keyword">final</span> <span class="keyword">int</span> orientationDegree)</span> </span>&#123;</span><br><span class="line">Matrix m = <span class="keyword">new</span> Matrix();</span><br><span class="line">       m.setRotate(orientationDegree, (<span class="keyword">float</span>) bm.getWidth() / <span class="number">2</span>, (<span class="keyword">float</span>) bm.getHeight() / <span class="number">2</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> Bitmap.createBitmap(bm, <span class="number">0</span>, <span class="number">0</span>, bm.getWidth(), bm.getHeight(), m, <span class="keyword">true</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (OutOfMemoryError ex) &#123;</span><br><span class="line">           ex.fillInStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> bm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bitmap bitmapImage = BitmapFactory.decodeByteArray(data, <span class="number">0</span>, data.length, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 这个 90 度太唐突了，但是能解决问题</span></span><br><span class="line">Bitmap newBitmap = adjustPhotoRotation(bitmapImage, <span class="number">90</span>);</span><br></pre></td></tr></table></figure><p>第二个是 requestBuilder 设置 JPEG_ORIENTATION，这种才是解决根本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDisplayRotation</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rotation = activity.getWindowManager().getDefaultDisplay()</span><br><span class="line">                .getRotation();</span><br><span class="line">        <span class="keyword">switch</span> (rotation) &#123;</span><br><span class="line">            <span class="keyword">case</span> Surface.ROTATION_0:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">90</span>;</span><br><span class="line">            <span class="keyword">case</span> Surface.ROTATION_90:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">case</span> Surface.ROTATION_180:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">270</span>;</span><br><span class="line">            <span class="keyword">case</span> Surface.ROTATION_270:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">180</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 requestBuilder 的时候设置</span></span><br><span class="line">mCaptureReqBuilder.set(CaptureRequest.JPEG_ORIENTATION, getDisplayRotation(activity));</span><br></pre></td></tr></table></figure><h4 id="CaptureRequest-Builder-NPE"><a href="#CaptureRequest-Builder-NPE" class="headerlink" title="CaptureRequest$Builder NPE"></a>CaptureRequest$Builder NPE</h4><p>完整报错信息是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.NullPointerException: Attempt to invoke virtual method <span class="string">&#x27;android.hardware.camera2.CaptureRequest$Builder android.hardware.camera2.CameraDevice.createCaptureRequest(int)&#x27;</span> on a <span class="keyword">null</span> object reference</span><br></pre></td></tr></table></figure><p>这是因为，相机驱动相关初始化后要延迟 1s 左右才能 buildCaptureRequest，post 一个延时 1s 的 runnable 即可</p><h4 id="部分机型上界面拉伸，保存正常"><a href="#部分机型上界面拉伸，保存正常" class="headerlink" title="部分机型上界面拉伸，保存正常"></a>部分机型上界面拉伸，保存正常</h4><p>试了很多，暂无解，待填</p>]]></content>
    
    
    <summary type="html">最近需要自定义 android camera2 实现连拍，此文为踩坑经验汇总</summary>
    
    
    
    <category term="Android" scheme="https://buyixiao.github.io/categories/Android/"/>
    
    
    <category term="camera2" scheme="https://buyixiao.github.io/tags/camera2/"/>
    
    <category term="android" scheme="https://buyixiao.github.io/tags/android/"/>
    
    <category term="连拍" scheme="https://buyixiao.github.io/tags/%E8%BF%9E%E6%8B%8D/"/>
    
  </entry>
  
  <entry>
    <title>pandas 分组频率统计</title>
    <link href="https://buyixiao.github.io/blog/pandas-groupby-frequency-statistics.html"/>
    <id>https://buyixiao.github.io/blog/pandas-groupby-frequency-statistics.html</id>
    <published>2022-05-28T12:50:25.000Z</published>
    <updated>2022-05-28T13:30:06.461Z</updated>
    
    <content type="html"><![CDATA[<p>假设有一个 dataframe 如下：</p><table><thead><tr><th align="center">country_name</th><th align="center">date</th><th align="center">标题</th></tr></thead><tbody><tr><td align="center">中国</td><td align="center">20030101</td><td align="center">今天是 2003 年第一天，我在中国</td></tr><tr><td align="center">安提瓜和巴布达</td><td align="center">20030101</td><td align="center">今天是 2003 年第一天，我在安提瓜和巴布达</td></tr><tr><td align="center">中国</td><td align="center">20030102</td><td align="center">今天是 2003 年第二天，我在中国</td></tr><tr><td align="center">蒙古</td><td align="center">20030102</td><td align="center">今天是 2003 年第二天，我在蒙古</td></tr></tbody></table><p>现在要统计每天每个国家在当天出现的频率，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># author:           inspurer(月小水长)</span></span><br><span class="line"><span class="comment"># create_time:      2022/5/28 20:10</span></span><br><span class="line"><span class="comment"># 运行环境           Python3.6+</span></span><br><span class="line"><span class="comment"># github            https://github.com/inspurer</span></span><br><span class="line"><span class="comment"># website           https://buyixiao.github.io/</span></span><br><span class="line"><span class="comment"># 微信公众号         月小水长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">input_file = <span class="string">&#x27;all_country.csv&#x27;</span></span><br><span class="line"></span><br><span class="line">df = pd.read_csv(input_file)</span><br><span class="line"></span><br><span class="line">res_df = df.groupby([<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;country_name&#x27;</span>]).count().reset_index()</span><br><span class="line"></span><br><span class="line">res_df = res_df[res_df.columns[:<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">res_df.rename(columns=&#123;<span class="string">&#x27;标题&#x27;</span>: <span class="string">&#x27;daily_cnt&#x27;</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res_df, res_df.columns)</span><br><span class="line"></span><br><span class="line">res_df[<span class="string">&#x27;daily_frq&#x27;</span>] = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(res_df.shape[<span class="number">0</span>])]</span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> res_df.iterrows():</span><br><span class="line">    res_df.loc[index, <span class="string">&#x27;daily_frq&#x27;</span>] = <span class="built_in">round</span>(row[<span class="string">&#x27;daily_cnt&#x27;</span>] / df[df[<span class="string">&#x27;date&#x27;</span>] == row[<span class="string">&#x27;date&#x27;</span>]].shape[<span class="number">0</span>], <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">res_df.to_csv(<span class="string">&quot;res_&quot;</span> + input_file, index=<span class="literal">False</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如有更优雅的方式（肯定有），请批评指正~</p>]]></content>
    
    
    <summary type="html">按照 A 列分组，统计 B 列下每个取值的频率</summary>
    
    
    
    <category term="Python" scheme="https://buyixiao.github.io/categories/Python/"/>
    
    
    <category term="groupby" scheme="https://buyixiao.github.io/tags/groupby/"/>
    
    <category term="pandas" scheme="https://buyixiao.github.io/tags/pandas/"/>
    
    <category term="frequency" scheme="https://buyixiao.github.io/tags/frequency/"/>
    
  </entry>
  
  <entry>
    <title>【持续更新|2022最新】68w 高质量新闻数据集</title>
    <link href="https://buyixiao.github.io/blog/qualitative-news-dataset.html"/>
    <id>https://buyixiao.github.io/blog/qualitative-news-dataset.html</id>
    <published>2022-05-14T15:36:29.000Z</published>
    <updated>2022-05-14T15:45:21.989Z</updated>
    
    <content type="html"><![CDATA[<p>租用服务器，累计半年有余对新浪，腾讯，澎湃三个国内主流新闻站点进行抓取，共计保存 68 w 数据，约 1.8G，导出到本地 csv 花了 5 个小时。</p><p>csv 一共 11 列，分别是：新闻抓取时间，标题，来源，头图，发布时间，链接，分类，关键词（逗号分隔），标签，描述，内容。</p><p>数据收集和整理获取花费大量时间和精力，故收取一定费用。下载地址：</p><p><a href="https://afdian.net/p/67bcb002d38f11ecad6152540025c377">https://afdian.net/p/67bcb002d38f11ecad6152540025c377</a></p><p>数据集不定期增量更新到上述下载地址~</p>]]></content>
    
    
    <summary type="html">抓取腾讯、新浪、澎湃新闻，11个字段，1.8G，68w 条</summary>
    
    
    
    <category term="爬虫" scheme="https://buyixiao.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="新闻" scheme="https://buyixiao.github.io/tags/%E6%96%B0%E9%97%BB/"/>
    
    <category term="数据集" scheme="https://buyixiao.github.io/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>话『雨』</title>
    <link href="https://buyixiao.github.io/blog/something-about-rain.html"/>
    <id>https://buyixiao.github.io/blog/something-about-rain.html</id>
    <published>2022-04-24T06:08:13.000Z</published>
    <updated>2022-04-24T06:15:42.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原载于博主大学期间的一篇空间日志。</p></blockquote><p>今晚自习走出世主楼，不觉已是沉沉的黑夜，还有一点小雨，雨滴滴答答地下，又湿又黑，此情此景，我没有汪国真“寒风冷雨”的感慨，倒是想起一些我和“雨”的那些陈年往事。</p><p>记忆中，我第一次见到对“雨”的文学性描述，大概是一首“大雨淅沥沥，小雨哗啦啦”的儿歌，活泼可爱的曲风，大概奠定了我一直以来对雨的好感。</p><p>一说到下雨，我向来是不喜欢打伞的，原因之一呢，是我太喜欢雨打在脸庞的那种感觉了，虽然意象不同，我这里还是想引用一句“吹面不寒杨柳风”来描绘，那种感觉呐，就像全身心地在和大自然交谈，窃窃私语，不可与人说；还有一个比较现实的原因就是，因为每次打伞，一般都是去参加某种公共活动，比如上学或者聚会，然后玩得欢欣了，一般就会把它遗忘在某个角落，再想起来时它已不在原地等我了，还有一次，那是上小学的时候，有一天放学，阴风怒号，我一个人穿过一段山路回家，在经过一个比较阴沉的水塘的时候，突然风大了起来，把我的伞给吹翻了，然后就飞到水塘里去了，雨很大，水塘很深，而我的手又短，真的是很绝望了。所以每次雨天回家，我妈总是质问我，伞哪去了，后面就懒得问了，只是拿干毛巾擦我的头，怕着凉。当然，如果雨是下的很大，倾盆大雨那种，或者是恰如“一桥清雨一伞开”这种妙不可言可遇不可求的意境，我是很乐意打伞的。 </p><p>下面就要把“雨”和我的吃货属性结合在一起了。 </p><p>梅雨季节，雨就一直下个不停，雨一停，我爸就带上我，以及一个捞鱼的网兜，去那些水渠与河流汇合的地方，用网兜一抄，必有各种野生的鲫鱼鲤鱼鲢鱼…，后来我上了高中，觉得可以用“下雨天新鲜的雨水含氧量太少，而这些汇合处因为和水流动性强结合氧气可能性大”之类的阐述来解释它，也算是学以致用吧。只是不知道为什么，这种时候捕的野生鱼，味道非常鲜美，我爸负责杀鱼，我负责去菜园里采青辣椒和大蒜，然后就是非常幸福的吃货时光了。</p><p> 如果这种时候我爸不带我玩的话，我通常会一个人去后山，它有个确切的名字叫［白鹭山］，说实话我倒没怎么见过白鹭，大小和白鹭相近，颜色和白鹭相似的一种湘南常见的菌类我倒见过不少(学名叫什么我现在也没查到，下次一定要用［形色］去辨一辨)，特别是下雨后，在马尾松的树根处、针丝叶铺得很厚的地方，一定有这种菌类的痕迹，每次拨开厚厚的叶子发现它，有两种思绪在我心中起伏，它这么可爱，又是一个新生的生命，你怎么舍得下手，但我终究只是凡夫俗子，到底垂涎它的美味，说到这，禁不住唾液的浸润了。 </p><p>许久未写一些无用的文字了，笔墨有些生疏，我的作文本也快一年没有动过了，是时候重新捡起来了。除了计算机，文学艺术确实是我生平另一大爱好，一来我这个俗人喜欢附庸风雅，二来用来打发时间，在物欲横流，利益至上的当今，还有什么比看这些无用书写无用字更舒服的呢，不为无用之事，何以遣有生之涯？</p>]]></content>
    
    
    <summary type="html">下雨了，想起和雨的一点往事~</summary>
    
    
    
    <category term="随笔" scheme="https://buyixiao.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="雨" scheme="https://buyixiao.github.io/tags/%E9%9B%A8/"/>
    
  </entry>
  
  <entry>
    <title>pandas 合并具有相同结构的 csv</title>
    <link href="https://buyixiao.github.io/blog/merge-csv-with-same-columns.html"/>
    <id>https://buyixiao.github.io/blog/merge-csv-with-same-columns.html</id>
    <published>2022-04-13T08:37:23.000Z</published>
    <updated>2022-04-22T04:23:43.905Z</updated>
    
    <content type="html"><![CDATA[<p>只要某文件夹下所有的 csv 文件结构相同，在文件夹路径运行以下代码就能自动合并，输出结果在 all.csv ，结果 csv 在原有的 csv 结构上新增一列 origin_file_name，值为原来的 csv 文件名，保证了没有信息的衰减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># author:           inspurer(月小水长)</span></span><br><span class="line"><span class="comment"># create_time:      2022/4/13 10:33</span></span><br><span class="line"><span class="comment"># 运行环境           Python3.6+</span></span><br><span class="line"><span class="comment"># github            https://github.com/inspurer</span></span><br><span class="line"><span class="comment"># website           https://buyixiao.github.io/</span></span><br><span class="line"><span class="comment"># 微信公众号         月小水长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">result_csv = <span class="string">&#x27;all.csv&#x27;</span></span><br><span class="line">all_cols = []</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">    <span class="keyword">if</span> file.endswith(<span class="string">&#x27;.csv&#x27;</span>) <span class="keyword">and</span> <span class="keyword">not</span> file == result_csv:</span><br><span class="line">        df = pd.read_csv(file)</span><br><span class="line">        all_cols = df.columns.values.tolist()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(all_cols) == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;当前目录下没有要合并的 csv 文件&quot;</span>)</span><br><span class="line">all_cols.insert(<span class="number">0</span>, <span class="string">&#x27;origin_file_name&#x27;</span>)</span><br><span class="line">all_df = pd.DataFrame(&#123;col: [] <span class="keyword">for</span> col <span class="keyword">in</span> all_cols&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">    <span class="keyword">if</span> file.endswith(<span class="string">&#x27;.csv&#x27;</span>) <span class="keyword">and</span> <span class="keyword">not</span> file == result_csv:</span><br><span class="line">        df = pd.read_csv(file)</span><br><span class="line">        df.insert(<span class="number">0</span>, <span class="string">&#x27;origin_file_name&#x27;</span>, [file <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(df.shape[<span class="number">0</span>])])</span><br><span class="line">        all_df = all_df.append(df, ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">all_df.to_csv(result_csv, index=<span class="literal">False</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">不需要指定 csv 有哪些列，把本代码放到具有同一结构的 csv 构成的文件夹中，运行代码就能合并所有 csv 并输出结果到 all.csv</summary>
    
    
    
    <category term="Python" scheme="https://buyixiao.github.io/categories/Python/"/>
    
    
    <category term="pandas" scheme="https://buyixiao.github.io/tags/pandas/"/>
    
    <category term="csv 合并" scheme="https://buyixiao.github.io/tags/csv-%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>pandas 分层抽样</title>
    <link href="https://buyixiao.github.io/blog/pandas-stratified-sampling.html"/>
    <id>https://buyixiao.github.io/blog/pandas-stratified-sampling.html</id>
    <published>2022-04-02T15:19:13.000Z</published>
    <updated>2022-04-13T08:54:19.059Z</updated>
    
    <content type="html"><![CDATA[<p>dataframe 里面要有 created_at 一列，格式 %Y-%m-%d %H:%M:%S，首先提取出小时，然后分层（组）抽样，保存到 csv 中，话不多说，上代码～</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># author:           inspurer(月小水长)</span></span><br><span class="line"><span class="comment"># create_time:      2022/4/2 22:58</span></span><br><span class="line"><span class="comment"># 运行环境           Python3.6+</span></span><br><span class="line"><span class="comment"># github            https://github.com/inspurer</span></span><br><span class="line"><span class="comment"># 微信公众号         月小水长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">input_file = <span class="string">&#x27;RussiaUkraine1.csv&#x27;</span></span><br><span class="line">output_file = <span class="string">&#x27;RussiaUkraine2.csv&#x27;</span></span><br><span class="line"></span><br><span class="line">df = pd.read_csv(input_file)</span><br><span class="line"><span class="comment"># 新增一列 hour</span></span><br><span class="line">df[<span class="string">&#x27;hour&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;created_at&#x27;</span>]).dt.hour  <span class="comment"># 时间</span></span><br><span class="line"><span class="comment"># 抽样比例 1%</span></span><br><span class="line">res_df = df.groupby(df[<span class="string">&#x27;hour&#x27;</span>]).apply(<span class="keyword">lambda</span> x: x.sample(frac=<span class="number">0.01</span>))</span><br><span class="line">res_df.to_csv(output_file, index=<span class="literal">False</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">将 dataframe 按照小时分层（组）后再按照比例随机抽样</summary>
    
    
    
    <category term="Python" scheme="https://buyixiao.github.io/categories/Python/"/>
    
    
    <category term="pandas" scheme="https://buyixiao.github.io/tags/pandas/"/>
    
    <category term="分层抽样" scheme="https://buyixiao.github.io/tags/%E5%88%86%E5%B1%82%E6%8A%BD%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>ip 访问正常，解析到此 ip 的域名却指向了 nginx 默认首页</title>
    <link href="https://buyixiao.github.io/blog/domainname-to-nginx-default-but-ip-to-ours.html"/>
    <id>https://buyixiao.github.io/blog/domainname-to-nginx-default-but-ip-to-ours.html</id>
    <published>2022-03-10T13:58:38.000Z</published>
    <updated>2022-03-10T14:37:51.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景环境"><a href="#背景环境" class="headerlink" title="背景环境"></a>背景环境</h3><p>硬件：阿里云 2 核 4 G 轻量应用级服务器</p><p>操作系统：Ubuntu 18.04.6 LTS</p><p> nginx version：nginx/1.14.0 (Ubuntu)</p><h3 id="故障表现"><a href="#故障表现" class="headerlink" title="故障表现"></a>故障表现</h3><p>域名成功解析到了 ip，此 ip 访问自己的应用正常，但是域名访问却指向了 nginx 的 index page。</p><h3 id="原因剖析"><a href="#原因剖析" class="headerlink" title="原因剖析"></a>原因剖析</h3><p>首先必须了解该问题涉及到的 nginx 的相关知识。</p><table><thead><tr><th align="center">nginx 相关配置</th><th align="center">路径</th></tr></thead><tbody><tr><td align="center">总配置文件</td><td align="center">/etc/nginx/nginx.conf</td></tr><tr><td align="center">nginx 配置的默认 server 配置文件</td><td align="center">/etc/nginx/sites-enabled/default</td></tr><tr><td align="center">我们自定义的 server 配置文件</td><td align="center">/etc/nginx/conf.d 下所有以 .conf 后缀的文件</td></tr></tbody></table><p>后面两个路径可以在总配置文件中找到：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line"><span class="attribute">include</span> /etc/nginx/sites-enabled/*;</span><br></pre></td></tr></table></figure><blockquote><p>注意第二个路径是 sites-enabled 而不是 sites-available，这两者区别可自行 google，相关知识和本文问题无关。</p></blockquote><p>nginx 默认的 server 配置文件如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">listen</span> [::]:<span class="number">80</span> default_server;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add index.php to the list if you are using PHP</span></span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">server_name</span> _;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">                <span class="comment"># First attempt to serve request as file, then</span></span><br><span class="line">                <span class="comment"># as directory, then fall back to displaying a 404.</span></span><br><span class="line">                <span class="attribute">try_files</span> $uri $uri/ =<span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而当前的 ip 与之对应的自定义 server 配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">upstream</span> django &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:9595</span>;  <span class="comment"># uwsgi 配置的ip和端口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;  <span class="comment"># 监听80端口</span></span><br><span class="line">    <span class="attribute">server_name</span> <span class="number">120.77.233.137</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 请求转发到 uwsgi 服务器</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://django;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置请求头，并将头信息传递给服务器端</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以自定义的 server_name 为 120.77.233.137，域名 kcool.top 访问时不会匹配到这个 server，就会交给 nginx 的 default_server 处理，也就到了 nginx 的 index page。</p><p>解决办法已经呼之欲出了。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>最好的解决办法是将域名 kcool.top 也加入我们自定义的 server_name 中，和现有的 ip 以空格分隔，即 :</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server_name</span> kcool.top <span class="number">120.77.233.137</span></span><br></pre></td></tr></table></figure><p>不得不说很多教程说多个 server_name 以逗号分隔实在是太坑了。</p><p>还有一种办法是将总配置文件的下面这行注释掉：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">include</span> /etc/nginx/sites-enabled/*;</span><br></pre></td></tr></table></figure><p>讲道理会 404 的，我也不知道为什么可行，有空再琢磨~</p>]]></content>
    
    
    <summary type="html">服务器 ip 访问应用正常，解析到此 ip 的域名指向了 nginx index 而不是自己的应用，本文将剖析原因及提出两种解决办法。</summary>
    
    
    
    <category term="nginx" scheme="https://buyixiao.github.io/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://buyixiao.github.io/tags/nginx/"/>
    
    <category term="default_server" scheme="https://buyixiao.github.io/tags/default-server/"/>
    
    <category term="域名解析" scheme="https://buyixiao.github.io/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>一站式微博可视化平台</title>
    <link href="https://buyixiao.github.io/blog/one-stop-weibo-visualization.html"/>
    <id>https://buyixiao.github.io/blog/one-stop-weibo-visualization.html</id>
    <published>2022-02-28T07:34:17.000Z</published>
    <updated>2022-04-21T16:43:32.443Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>抽空写了一个微博可视化的网站，前端基于 sb-admin-2，后端基于 django3，微博相关数据则来源于本站维护的 <a href="https://buyixiao.github.io/blog/weibo-super-spider.html">微博超级爬虫系列</a>。</p><p>网站旨在成为一站式微博可视化分析平台，可以选择按照话题/关键词、位置、用户等维度聚合微博进行总体可视分析，也可以选择某一条微博，对它的转发、评论和点赞数据进行透视分析。以及满足个性化的可视化需求。</p><h3 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h3><p>域名访问：<a href="http://weibo.buyixiao.xyz/">http://weibo.buyixiao.xyz</a><br>备用访问：<a href="http://8.142.38.214:9920/">http://8.142.38.214:9920</a></p><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><h4 id="2022-02-08"><a href="#2022-02-08" class="headerlink" title="2022/02/08"></a>2022/02/08</h4><p>网站上线，只完成了对用户/话题微博的时间分布、地理分布、转评赞榜、情感分析，词云等可视分析，可以直观看到用户/话题的数据表；以及一个简易的评论多级转发可视化。</p><p>不能自动抓取微博话题，需要抓取分析的话题请在文末留言，将定期查看留言话题进行抓取分析，并将话题数据导入网站，可视分析结果可直接在网页下载，下载按钮就在每一个图表的右上角。</p><h4 id="2022-02-28"><a href="#2022-02-28" class="headerlink" title="2022/02/28"></a>2022/02/28</h4><p>新上线接口 <a href="http://weibo.buyixiao.xyz/custom-vis/topics-daily-sentiment-compare-visual/">/custom-vis/topics-daily-sentiment-compare-visual/</a>；读者可以自行上传多个话题爬虫的 csv 文件进行对比情感分析可视化。</p><h4 id="2022-03-03"><a href="#2022-03-03" class="headerlink" title="2022/03/03"></a>2022/03/03</h4><p>新上线 location 栏目；收录北京一众高等院校和鸟巢、奥森、鼓楼、景山公园、三里屯等 50 个地标近 5w 条最新微博。</p><h4 id="2022-03-05"><a href="#2022-03-05" class="headerlink" title="2022/03/05"></a>2022/03/05</h4><p>新上线李文亮先生 <a href="https://weibo.com/1139098205/Is9M7taaY">最后一条微博</a> 的评论 LDA 分析，抓取数万条评论，计算确定最优主题困惑度为 5。分析结果地址：<a href="http://weibo.buyixiao.xyz/comment/liwenliang">/comment/liwenliang</a> 。</p><h4 id="2022-04-22"><a href="#2022-04-22" class="headerlink" title="2022/04/22"></a>2022/04/22</h4><p>新上线接口 <a href="http://weibo.buyixiao.xyz/custom-vis/topic-user-co-occurrence-visual/">/custom-vis/topic-user-co-occurrence-visual/</a> ；读者可自行上传话题 csv 文件提取文本中的相互艾特好友的人物共现网络。</p>]]></content>
    
    
    <summary type="html">一键可视分析用户微博、话题微博，位置微博，以及定制可视化，结果可下载。</summary>
    
    
    
    <category term="可视化" scheme="https://buyixiao.github.io/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
    <category term="可视化" scheme="https://buyixiao.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="echarts" scheme="https://buyixiao.github.io/tags/echarts/"/>
    
  </entry>
  
  <entry>
    <title>开源|微博备份助手</title>
    <link href="https://buyixiao.github.io/blog/weibo-user-backup.html"/>
    <id>https://buyixiao.github.io/blog/weibo-user-backup.html</id>
    <published>2022-02-16T10:30:55.000Z</published>
    <updated>2022-02-16T10:47:35.049Z</updated>
    
    <content type="html"><![CDATA[<h3 id="扩展介绍"><a href="#扩展介绍" class="headerlink" title="扩展介绍"></a>扩展介绍</h3><p>得空写了个微博用户备份助手。</p><p>它的作用是备份用户自己或者任意微博用户的微博数据，并将结果保存到本地的 xlsx 文件。</p><p><img src="https://s2.loli.net/2022/02/16/TKsNObdBpVhultv.png" alt="weibo_backup_show_zip.png"></p><h3 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h3><p>1、确保在浏览器登录了 weibo.cn</p><p>2、在 weibo.cn 或者 weibo.com 站点内的微博用户主页上点击扩展图标，会显示如上图，自动解析数字 uid，然后点击开始抓取按钮即可；如果自动解析失败，可手动输入然后抓取；如果自定义微博主页用户的数字 uid 获取方式为：在它的主页上任意一条微博上的用户名右键在新标签页打开，浏览器地址栏就能看到数字 uid 了。</p><p>3、抓取时请勿离开页面或者关闭扩展，抓取结束会自动保存 lxsx，每 增量 200 条也会全部保存一次到 lxsx，因此抓取过程中会有多个 lxsx 文件生成，以最后的文件为准。</p><h3 id="安装地址"><a href="#安装地址" class="headerlink" title="安装地址"></a>安装地址</h3><p>上线了 google 商城，可一在线安装。</p><blockquote><p><a href="https://chrome.google.com/webstore/detail/%E5%BE%AE%E5%8D%9A%E5%A4%87%E4%BB%BD%E5%8A%A9%E6%89%8B/kbgjdcobjobchmhfddlfjnnlaaoiejla?hl=zh-CN">https://chrome.google.com/webstore/detail/%E5%BE%AE%E5%8D%9A%E5%A4%87%E4%BB%BD%E5%8A%A9%E6%89%8B/kbgjdcobjobchmhfddlfjnnlaaoiejla?hl=zh-CN</a></p></blockquote><p>代码开源在 github，也可通过源码安装。</p><blockquote><p><a href="https://github.com/Python3Spiders/WeiboBackupExtension">https://github.com/Python3Spiders/WeiboBackupExtension</a></p></blockquote>]]></content>
    
    
    <summary type="html">一个备份指定微博用户发布微博的浏览器扩展，保存为本地 xlsx</summary>
    
    
    
    <category term="Chrome Extension" scheme="https://buyixiao.github.io/categories/Chrome-Extension/"/>
    
    
    <category term="微博用户爬虫" scheme="https://buyixiao.github.io/tags/%E5%BE%AE%E5%8D%9A%E7%94%A8%E6%88%B7%E7%88%AC%E8%99%AB/"/>
    
    <category term="微博备份" scheme="https://buyixiao.github.io/tags/%E5%BE%AE%E5%8D%9A%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>flask 获取被 nginx 反向代理的客户端真实 ip</title>
    <link href="https://buyixiao.github.io/blog/client-real-ip-proxy-by-nginx.html"/>
    <id>https://buyixiao.github.io/blog/client-real-ip-proxy-by-nginx.html</id>
    <published>2022-02-10T09:27:09.000Z</published>
    <updated>2022-02-10T09:44:54.225Z</updated>
    
    <content type="html"><![CDATA[<p>服务端为了防爬虫或其他用途，需要获取客户端真实 ip，在 flask 中获取客户端 ip 的方法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip = request.remote_addr <span class="comment">#写在 view 中</span></span><br></pre></td></tr></table></figure><p>但是通过 nginx 反向代理后，获取的 ip 全部变成了 127.0.0.1。</p><p>可以在 nginx 中的配置文件中 location 下块添加一行：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置请求头，并将头信息传递给服务器端</span></span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br></pre></td></tr></table></figure><p>然后在 flask 中通过以下代码就能获取真实 ip 了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip = request.headers[<span class="string">&#x27;X-Real-IP&#x27;</span>]</span><br></pre></td></tr></table></figure><p>很多类似的教程坑在，只给出一个类似 <code>ip = request.headers[&#39;X-Forwarded-For&#39;] </code>根本不告诉你 headers 的这个 key 是在 nginx 中配置的。</p>]]></content>
    
    
    <summary type="html">获取被 nginx 反向代理 ip 的保姆级教程，知其所以然。</summary>
    
    
    
    <category term="Python" scheme="https://buyixiao.github.io/categories/Python/"/>
    
    
    <category term="python" scheme="https://buyixiao.github.io/tags/python/"/>
    
    <category term="flask" scheme="https://buyixiao.github.io/tags/flask/"/>
    
    <category term="nginx" scheme="https://buyixiao.github.io/tags/nginx/"/>
    
    <category term="ip" scheme="https://buyixiao.github.io/tags/ip/"/>
    
  </entry>
  
</feed>
